package main

import (
	"bufio"
	"fmt"
	"math/rand"
	"os"
	"sort"
	"strings"

	"golang.org/x/text/encoding/charmap"
)

type Word struct {
	word   string
	alphas [][]rune
}

var (
	wordlist []Word
	wordmap  map[string]string
)

func main() {
	wordmap = make(map[string]string)
	words, err := readLines("words.txt")
	if err != nil {
		panic(err)
	}
	wordlist = make([]Word, 0)
	for _, word := range words {
		wordmap[word] = word
		alphas := make([][]rune, 0, 0)
		for _, r := range word {
			alpha := make([]rune, 0, 0)
			alpha = append(alpha, r)
			alphas = append(alphas, alpha)
		}
		for row := 0; row < 5; row++ {
			for col := 1; col < 6; col++ {
				r := randSeq(alphas[row])
				save := alphas[row]
				alphas[row] = append(alphas[row], r)
				for !runeok(alphas, word) {
					alphas[row] = save
					r := randSeq(alphas[row])
					alphas[row] = append(alphas[row], r)
				}
			}
		}
		for idx := 0; idx < 5; idx++ {
			row := alphas[idx]
			sort.Slice(row, func(x, y int) bool {
				return row[x] < row[y]
			})
		}
		w := Word{
			word:   word,
			alphas: alphas,
		}
		wordlist = append(wordlist, w)
	}

	filename := "../password/src/passwords.h"
	os.Remove(filename)
	f, err := os.OpenFile(filename, os.O_CREATE, os.ModePerm)
	if err != nil {
		panic(err)
	}
	defer f.Close()
	encode(f, "#include <Arduino.h>\r\n")
	encode(f, "\r\n")
	encode(f, "// generated by hi-tane go password utils")
	encode(f, "\r\n")
	encode(f, fmt.Sprintf("const byte PWD_COUNT = %d;\r\n", len(wordlist)))
	ids := make([]string, 0)
	for x, word := range wordlist {
		id := fmt.Sprintf("wd_%.2d", x)
		encode(f, fmt.Sprintf("const char %s[] PROGMEM = \"%s\";\r\n", id, word.word))
		ids = append(ids, id)
		for y := range 5 {
			id := fmt.Sprintf("wd_%.2d_%.2d", x, y)
			encode(f, fmt.Sprintf("const char %s[] PROGMEM = \"%s\";\r\n", id, string(word.alphas[y])))
			ids = append(ids, id)
		}
	}

	encode(f, "\r\n")
	encode(f, "PGM_P const pwd[] PROGMEM = {")
	for x, id := range ids {
		if x%6 == 0 {
			encode(f, "  ")
		}
		fmt.Fprintf(f, "%s", id)
		if x < len(ids)-1 {
			encode(f, ", ")
		}
		if x%6 == 5 {
			encode(f, "\r\n")
		}

	}
	encode(f, "};\r\n")
}

func runeok(alphas [][]rune, word string) bool {
	for a0 := range len(alphas[0]) {
		for a1 := range len(alphas[1]) {
			for a2 := range len(alphas[2]) {
				for a3 := range len(alphas[3]) {
					for a4 := range len(alphas[4]) {
						my := string(alphas[0][a0]) + string(alphas[1][a1]) + string(alphas[2][a2]) + string(alphas[3][a3]) + string(alphas[4][a4])
						_, ok := wordmap[my]
						if ok && (my != word) {
							return false
						}
					}
				}
			}
		}
	}
	return true
}

var letters = []rune("aäbcdefghijklmnoöpqrsßtuüvwxyz")

func randSeq(not []rune) rune {
	r := not[0]
	for isin(r, not) {
		r = letters[rand.Intn(len(letters))]
	}
	return r
}

func isin(c rune, rs []rune) bool {
	for _, r := range rs {
		if c == r {
			return true
		}
	}
	return false
}

func notReady(alphas [][]rune) bool {
	for _, row := range alphas {
		if len(row) < 1 {
			return false
		}
	}
	return true
}

// readLines reads a whole file into memory
// and returns a slice of its lines.
func readLines(path string) ([]string, error) {
	file, err := os.Open(path)
	if err != nil {
		return nil, err
	}
	defer file.Close()

	var lines []string
	scanner := bufio.NewScanner(file)
	for scanner.Scan() {
		lines = append(lines, scanner.Text())
	}
	return lines, scanner.Err()
}

func encode(f *os.File, line string) {
	line = strings.ReplaceAll(line, "ä", "\\xe4\"\"")
	line = strings.ReplaceAll(line, "ö", "\\xf6\"\"")
	line = strings.ReplaceAll(line, "ü", "\\xfc\"\"")
	line = strings.ReplaceAll(line, "ß", "\\xdf\"\"")
	line = strings.ReplaceAll(line, "Ä", "\\xc4\"\"")
	line = strings.ReplaceAll(line, "Ö", "\\xd6\"\"")
	line = strings.ReplaceAll(line, "Ü", "\\xdc\"\"")
	enc := charmap.Windows1252.NewEncoder()
	b, err := enc.Bytes([]byte(line))
	if err != nil {
		panic(err)
	}
	_, err = f.Write(b)
	if err != nil {
		panic(err)
	}
}
